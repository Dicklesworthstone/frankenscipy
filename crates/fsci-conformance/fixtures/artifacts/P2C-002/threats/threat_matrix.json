{
  "schema_version": 1,
  "packet_id": "FSCI-P2C-002",
  "domain": "linalg",
  "generated_at": "2026-02-14T06:40:00Z",
  "threat_categories": ["numerical", "malformed_input", "resource", "compatibility", "security"],
  "threats": [
    {
      "id": "THREAT-P2C002-001",
      "category": "numerical",
      "title": "Near-singular matrix in solve/inv",
      "severity": "critical",
      "affected_functions": ["solve", "inv", "solve_triangular"],
      "description": "When the input matrix has a condition number approaching or exceeding 1/eps (~4.5e15 for f64), the LU factorization may complete without error but produce a solution with no significant digits. SciPy's LAPACK wrappers rely on INFO return to detect exact singularity (zero pivot) but do not check rcond for near-singularity by default.",
      "attack_vector": "Adversarial input matrix crafted to have condition number just below detection threshold. The LAPACK dgesv will return INFO=0 (success) but the solution x satisfies ||Ax - b|| / ||b|| >> 1.",
      "strict_mode_mitigation": "Return the LAPACK result as-is, matching SciPy behavior. The rcond is not estimated unless explicitly requested. This matches the SciPy contract where near-singular is not an error.",
      "hardened_mode_mitigation": "Estimate rcond via dgecon after factorization. If rcond < 1e-14, emit ConditionWarning. If rcond < 1e-15 (effectively singular), return SingularMatrix error. This is fail-closed behavior not present in SciPy.",
      "test_fixture_ref": "P2C-002/threats/test_near_singular.json",
      "invariant_violated": "norm(A @ x - b) / norm(b) < rtol * cond(A) + atol"
    },
    {
      "id": "THREAT-P2C002-002",
      "category": "numerical",
      "title": "Catastrophic cancellation in determinant for large matrices",
      "severity": "high",
      "affected_functions": ["det"],
      "description": "For large matrices (N > 50), the determinant computed as product of LU diagonal can overflow to Inf or underflow to 0, even when the true determinant is representable. The product of N values each near 1.0 can lose precision through accumulated rounding. SciPy computes det = sign * product(diag(U)) which overflows for det > 1e308.",
      "attack_vector": "Matrix with eigenvalues all slightly > 1.0, producing a determinant that overflows f64. Or matrix with eigenvalues alternating large/small, producing catastrophic cancellation in the product.",
      "strict_mode_mitigation": "Compute det as SciPy does: sign_permutation * product(diag(U)). Accept overflow to Inf and underflow to 0 as valid results, matching SciPy.",
      "hardened_mode_mitigation": "Compute det in log-space: sign * exp(sum(log(abs(diag(U))))). Warn if the result would overflow/underflow in direct computation. For complex matrices, track phase separately.",
      "test_fixture_ref": "P2C-002/threats/test_det_overflow.json",
      "invariant_violated": "det(A) must be finite for non-singular A with representable determinant"
    },
    {
      "id": "THREAT-P2C002-003",
      "category": "malformed_input",
      "title": "Non-finite values with check_finite=false",
      "severity": "high",
      "affected_functions": ["solve", "inv", "det", "lstsq", "pinv", "solve_triangular", "solve_banded"],
      "description": "When check_finite=false, NaN or Inf values in input matrices bypass validation. LAPACK routines have undefined behavior with non-finite inputs: they may produce NaN outputs, infinite loops, or segfault (in C LAPACK). SciPy documents this as 'may result in erroneous results' but does not crash.",
      "attack_vector": "Pass a matrix containing strategic NaN/Inf values with check_finite=false to trigger undefined LAPACK behavior.",
      "strict_mode_mitigation": "Honor check_finite=false by skipping the finite check, matching SciPy. Document that results are undefined for non-finite inputs when check_finite=false.",
      "hardened_mode_mitigation": "Always perform finite check regardless of check_finite flag. Return NonFiniteInput error if any NaN/Inf detected. The check_finite parameter is ignored in hardened mode (defense-in-depth).",
      "test_fixture_ref": "P2C-002/threats/test_nonfinite_bypass.json",
      "invariant_violated": "All outputs must be well-defined for all valid mode combinations"
    },
    {
      "id": "THREAT-P2C002-004",
      "category": "malformed_input",
      "title": "Shape mismatch between A and b in solve",
      "severity": "medium",
      "affected_functions": ["solve", "solve_triangular", "solve_banded", "lstsq"],
      "description": "Incompatible shapes between the matrix A and right-hand side b. SciPy validates shapes and raises ValueError with descriptive messages. The Rust implementation must produce equivalent error messages for conformance.",
      "attack_vector": "Pass A of shape (3,3) with b of shape (4,) to trigger shape validation. Or pass A of shape (3,4) (non-square) to solve.",
      "strict_mode_mitigation": "Validate shapes before any computation. Error messages must match SciPy patterns for conformance test compliance.",
      "hardened_mode_mitigation": "Same as strict. Shape validation is the first check in all modes.",
      "test_fixture_ref": "P2C-002/threats/test_shape_mismatch.json",
      "invariant_violated": "Shape errors must be detected before any computation begins"
    },
    {
      "id": "THREAT-P2C002-005",
      "category": "malformed_input",
      "title": "Invalid assume_a structure hint",
      "severity": "medium",
      "affected_functions": ["solve", "inv"],
      "description": "The assume_a parameter can be set to an invalid value or to a structure that doesn't match the actual matrix. SciPy validates the string value but does NOT validate that the matrix actually has the claimed structure. Claiming 'positive definite' for a non-PD matrix will cause LAPACK dpotrf to fail with INFO > 0.",
      "attack_vector": "Pass assume_a='positive definite' with a matrix that has negative eigenvalues. Or pass an unrecognized string value. Or pass assume_a='symmetric' with an asymmetric matrix (SciPy silently uses only the lower/upper triangle).",
      "strict_mode_mitigation": "Validate the string/enum value. Do NOT validate that the matrix matches the claimed structure (matches SciPy). If LAPACK reports failure due to structural mismatch (e.g., not actually PD), propagate the LAPACK error.",
      "hardened_mode_mitigation": "Validate the enum value AND verify the claimed structure: for 'symmetric', check ||A - A^T|| < eps*||A||. For 'positive definite', attempt Cholesky and fall back to general if it fails. For 'triangular', verify off-triangle is zero.",
      "test_fixture_ref": "P2C-002/threats/test_invalid_assume_a.json",
      "invariant_violated": "Error messages for invalid assume_a must match SciPy patterns"
    },
    {
      "id": "THREAT-P2C002-006",
      "category": "numerical",
      "title": "Triangular solve with near-zero diagonal elements",
      "severity": "high",
      "affected_functions": ["solve_triangular"],
      "description": "A triangular matrix with very small (but non-zero) diagonal elements can produce an extremely ill-conditioned triangular system. LAPACK dtrtrs will not report an error (INFO=0) since no exact zero is found, but the solution will be dominated by rounding errors. The reciprocal condition number may be as small as min(|d_ii|)/max(|d_ii|).",
      "attack_vector": "Craft a triangular matrix with diagonal elements spanning 15+ orders of magnitude. The solve will appear to succeed but the solution has no meaningful digits.",
      "strict_mode_mitigation": "Return the LAPACK result without additional checks, matching SciPy behavior where no condition warning is emitted for triangular solve.",
      "hardened_mode_mitigation": "Compute min(|d_ii|)/max(|d_ii|) as a proxy for rcond. If this ratio < eps * N, emit ConditionWarning. If ratio < eps, fail with SingularMatrix error.",
      "test_fixture_ref": "P2C-002/threats/test_tri_near_singular.json",
      "invariant_violated": "norm(A @ x - b) / norm(b) should be bounded by cond(A) * eps"
    },
    {
      "id": "THREAT-P2C002-007",
      "category": "resource",
      "title": "O(N^3) memory and compute for large dense matrices",
      "severity": "high",
      "affected_functions": ["solve", "inv", "det", "lstsq", "pinv"],
      "description": "Dense linear algebra operations require O(N^2) memory for the matrix and O(N^3) compute for factorization. For N=10000, this is 800MB for f64 and ~30 seconds of compute. For N=50000, this is 20GB and many minutes. No built-in size limits exist in SciPy.",
      "attack_vector": "Pass an extremely large matrix (N > 10000) to trigger excessive memory allocation or long-running computation. In a server context, this could be a denial-of-service vector.",
      "strict_mode_mitigation": "No size limits, matching SciPy. The caller is responsible for resource management.",
      "hardened_mode_mitigation": "Configurable size limits via FSCI_MAX_DENSE_DIM environment variable or runtime config. Default: warn at N > 5000, error at N > 50000. For lstsq/pinv which require SVD (more expensive), lower thresholds: warn at N > 2000.",
      "test_fixture_ref": "P2C-002/threats/test_resource_limits.json",
      "invariant_violated": "Resource consumption must be bounded in hardened mode"
    },
    {
      "id": "THREAT-P2C002-008",
      "category": "compatibility",
      "title": "Auto-detection dispatch differences across SciPy versions",
      "severity": "medium",
      "affected_functions": ["solve", "inv"],
      "description": "SciPy 1.14+ introduced auto-detection of matrix structure when assume_a=None. The detection order (diagonal, triangular, symmetric, positive-definite, general) and the heuristics used may differ between SciPy versions. Earlier versions (< 1.14) only supported explicit structure hints. Our implementation targets SciPy 1.17 behavior.",
      "attack_vector": "Code written against SciPy < 1.14 that relies on always-general solve behavior may break if auto-detection selects a different algorithm path.",
      "strict_mode_mitigation": "Implement exactly the SciPy 1.17 auto-detection logic. Detection order: (1) check diagonal, (2) check upper/lower triangular, (3) check symmetric, (4) check positive definite via small Cholesky probe, (5) fall back to general. Document this as target version behavior.",
      "hardened_mode_mitigation": "Disable auto-detection entirely. Require explicit assume_a specification. If assume_a=None, use General (safest). This eliminates the auto-detection attack surface.",
      "test_fixture_ref": "P2C-002/threats/test_autodetect_compat.json",
      "invariant_violated": "Algorithm selection must be deterministic and match SciPy 1.17"
    },
    {
      "id": "THREAT-P2C002-009",
      "category": "numerical",
      "title": "Banded storage format corruption",
      "severity": "high",
      "affected_functions": ["solve_banded"],
      "description": "LAPACK banded storage format (ab[u+i-j, j] == a[i,j]) is an opaque encoding. If the caller provides incorrect l_and_u values or fills the ab array incorrectly, LAPACK dgbsv may read garbage data from out-of-band positions, produce incorrect results, or report spurious singularity.",
      "attack_vector": "Provide l_and_u=(2,1) but fill ab as if l_and_u=(1,2). The shape check passes (both need 4 rows) but the data is interpreted incorrectly. Or provide l_and_u values larger than the matrix dimension.",
      "strict_mode_mitigation": "Validate ab.shape[0] == l+u+1. Do not validate content (matches SciPy). Trust the caller's banded encoding.",
      "hardened_mode_mitigation": "Additionally validate: l >= 0, u >= 0, l < M, u < M, l+u < M. For small matrices (M < 100), reconstruct the dense matrix from banded format and verify the solve produces the same result (double-check).",
      "test_fixture_ref": "P2C-002/threats/test_banded_format_corruption.json",
      "invariant_violated": "ab.shape[0] == l + u + 1 and l,u < M"
    },
    {
      "id": "THREAT-P2C002-010",
      "category": "numerical",
      "title": "Least-squares driver inconsistency for rank-deficient systems",
      "severity": "medium",
      "affected_functions": ["lstsq"],
      "description": "The three LAPACK drivers (gelsd, gelsy, gelss) may determine different effective ranks for the same matrix and cond parameter. gelsd and gelss use SVD with different implementations; gelsy uses QR with column pivoting. For matrices near the rank threshold, the solutions can differ significantly.",
      "attack_vector": "Craft a matrix with singular values near the cond threshold. Different drivers will disagree on rank and produce different solutions. Switching drivers changes the answer.",
      "strict_mode_mitigation": "Default to gelsd (matching SciPy). Allow driver override. Document that rank determination may differ between drivers. The effective rank depends on the cond threshold and the driver's singular value computation.",
      "hardened_mode_mitigation": "Only allow gelsd (most robust). If rank differs between gelsd and gelss (cross-check), emit InconsistentRank warning. Report all singular values to allow caller inspection.",
      "test_fixture_ref": "P2C-002/threats/test_lstsq_driver_inconsistency.json",
      "invariant_violated": "rank <= min(M, N) and singular_values are non-negative descending"
    },
    {
      "id": "THREAT-P2C002-011",
      "category": "numerical",
      "title": "Pseudo-inverse threshold sensitivity",
      "severity": "medium",
      "affected_functions": ["pinv"],
      "description": "The effective rank of the pseudo-inverse is determined by max(atol, rtol * sv_max). When atol=0 and rtol=0 (both explicitly set to zero by caller), all singular values are kept, even those at machine epsilon level. This produces a pseudo-inverse dominated by noise amplification from the smallest singular values.",
      "attack_vector": "Call pinv(A, atol=0, rtol=0) on a rank-deficient matrix. The pseudo-inverse will have enormous entries corresponding to near-zero singular values, producing norm(pinv(A)) >> norm(A).",
      "strict_mode_mitigation": "Honor the caller's atol/rtol values exactly, matching SciPy behavior where atol=0, rtol=0 keeps all singular values.",
      "hardened_mode_mitigation": "If both atol=0 and rtol=0, override to rtol=max(M,N)*eps with a warning. Never allow zero threshold in hardened mode.",
      "test_fixture_ref": "P2C-002/threats/test_pinv_zero_threshold.json",
      "invariant_violated": "pinv(A) @ A @ pinv(A) approximately equals pinv(A)"
    },
    {
      "id": "THREAT-P2C002-012",
      "category": "security",
      "title": "Timing side-channel in structure auto-detection",
      "severity": "low",
      "affected_functions": ["solve", "inv"],
      "description": "The auto-detection sequence (diagonal, triangular, symmetric, positive-definite) tests each structure in order and short-circuits on first match. This means the execution time reveals information about the matrix structure to an observer who can measure timing.",
      "attack_vector": "In a shared-compute environment, measure solve() execution time to infer whether the input matrix was diagonal (fastest), triangular, symmetric, or general (slowest). This leaks structural information about private data.",
      "strict_mode_mitigation": "No mitigation needed. SciPy has the same timing behavior. Structure auto-detection inherently reveals structure through timing.",
      "hardened_mode_mitigation": "Disable auto-detection (require explicit assume_a). Or: always run all detection checks and select the most specific structure, making timing constant regardless of actual structure. Document the timing behavior in security notes.",
      "test_fixture_ref": "P2C-002/threats/test_timing_sidechannel.json",
      "invariant_violated": "Execution time should not reveal matrix structure in hardened mode"
    },
    {
      "id": "THREAT-P2C002-013",
      "category": "compatibility",
      "title": "Complex transposed solve not supported",
      "severity": "medium",
      "affected_functions": ["solve"],
      "description": "SciPy raises NotImplementedError when solve(A, b, transposed=True) is called with complex A. This is a known SciPy limitation. Our implementation must match this error exactly for conformance, even though the mathematical operation is well-defined.",
      "attack_vector": "Call solve with complex matrix and transposed=True expecting a valid result. Must get the same error as SciPy.",
      "strict_mode_mitigation": "Raise NotSupported error matching SciPy's NotImplementedError message pattern. This is a deliberate conformance choice.",
      "hardened_mode_mitigation": "Same as strict. Additionally, implement the complex transposed solve correctly and gate it behind a feature flag (fsci_extended_complex_solve) for users who need it. Default: error for conformance.",
      "test_fixture_ref": "P2C-002/threats/test_complex_transposed.json",
      "invariant_violated": "Error behavior must match SciPy exactly in strict mode"
    },
    {
      "id": "THREAT-P2C002-014",
      "category": "resource",
      "title": "LAPACK workspace query failure",
      "severity": "low",
      "affected_functions": ["lstsq", "pinv", "inv"],
      "description": "LAPACK routines require workspace arrays sized based on matrix dimensions. The workspace query (LWORK=-1 call) may return an insufficient size estimate in edge cases (extremely large matrices near size_t limits, or LAPACK implementation bugs). In SciPy, workspace allocation failure triggers MemoryError.",
      "attack_vector": "Pass a matrix large enough that the workspace query returns a size exceeding available memory. Or a degenerate dimension (M=0 or N=0) that confuses the workspace query.",
      "strict_mode_mitigation": "Pre-compute workspace size using the formula max(1, 2*N) for most routines. Handle empty matrices (M=0 or N=0) as special cases before LAPACK call.",
      "hardened_mode_mitigation": "Cap workspace allocation at FSCI_MAX_WORKSPACE (default 1GB). If the required workspace exceeds this, return ResourceExhausted error. Validate all dimensions are >= 0 before workspace computation.",
      "test_fixture_ref": "P2C-002/threats/test_workspace_limits.json",
      "invariant_violated": "Workspace allocation must not exceed configurable bounds in hardened mode"
    }
  ],
  "fail_closed_policy": {
    "description": "In hardened mode, any unrecognized or ambiguous condition results in an error rather than a potentially incorrect result. This is the 'fail-closed' principle.",
    "triggers": [
      "Unknown assume_a variant",
      "Matrix condition number exceeds hardened threshold (1e15)",
      "Non-finite input values regardless of check_finite flag",
      "Resource limits exceeded",
      "Inconsistent rank determination between algorithms"
    ],
    "default_action": "Return an error with descriptive message. Never return a potentially incorrect result silently."
  },
  "cross_references": {
    "behavior_ledger": "fixtures/artifacts/P2C-002/anchor/behavior_ledger.json",
    "contract_table": "fixtures/artifacts/P2C-002/contracts/contract_table.json",
    "comprehensive_spec_section": "Section 9 (Threat Model) and Section 17 (Performance Sentinels)"
  }
}
